#!/usr/bin/env python3
"""
Enhanced SeaSense AI Trust Engine & Dashboard Startup Script
This script starts both the backend AI trust engine and the frontend dashboard
with proper integration and health monitoring.
"""

import os
import sys
import time
import signal
import subprocess
import threading
import requests
from pathlib import Path
import json

class SeaSenseOrchestrator:
    def __init__(self):
        self.base_dir = Path(__file__).parent
        self.ai_engine_dir = self.base_dir / "ai_trust_engine"
        self.dashboard_dir = self.base_dir / "seasense-dashboard"
        
        self.backend_process = None
        self.frontend_process = None
        self.health_monitor_thread = None
        self.shutdown_event = threading.Event()
        
        # Configuration
        self.backend_host = "127.0.0.1"
        self.backend_port = 8005
        self.frontend_port = 3000
        
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

    def signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully"""
        print(f"\nüõë Received signal {signum}, shutting down gracefully...")
        self.shutdown()

    def check_dependencies(self):
        """Check if required dependencies are available"""
        print("üîç Checking dependencies...")
        
        # Check Python dependencies
        if not (self.ai_engine_dir / "requirements.txt").exists():
            print("‚ùå AI Engine requirements.txt not found")
            return False
        
        # Check Node.js dependencies
        if not (self.dashboard_dir / "package.json").exists():
            print("‚ùå Dashboard package.json not found")
            return False
        
        # Check if uvicorn is available
        try:
            subprocess.run(["python", "-m", "uvicorn", "--help"], 
                         capture_output=True, check=True, cwd=self.ai_engine_dir)
        except (subprocess.CalledProcessError, FileNotFoundError):
            print("‚ùå uvicorn not available. Please install AI engine dependencies:")
            print(f"   cd {self.ai_engine_dir} && pip install -r requirements.txt")
            return False
        
        # Check if npm/yarn is available
        npm_available = False
        try:
            subprocess.run(["npm", "--version"], capture_output=True, check=True)
            npm_available = True
        except (subprocess.CalledProcessError, FileNotFoundError):
            try:
                subprocess.run(["yarn", "--version"], capture_output=True, check=True)
                npm_available = True
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
        
        if not npm_available:
            print("‚ùå Neither npm nor yarn is available. Please install Node.js")
            return False
        
        print("‚úÖ All dependencies available")
        return True

    def setup_environment(self):
        """Setup environment files and configurations"""
        print("‚öôÔ∏è  Setting up environment...")
        
        # Create .env.local if it doesn't exist
        env_local = self.dashboard_dir / ".env.local"
        if not env_local.exists():
            env_content = f"""# Auto-generated by SeaSense startup script
NEXT_PUBLIC_API_BASE_URL=http://{self.backend_host}:{self.backend_port}
NEXT_PUBLIC_APP_NAME=SeaSense AI Trust Engine Dashboard
NEXT_PUBLIC_VERSION=1.0.0
NEXT_PUBLIC_ENABLE_WEBSOCKETS=false
NEXT_PUBLIC_UPDATE_INTERVAL=30000
NEXT_PUBLIC_DEFAULT_MAP_CENTER_LAT=19.076
NEXT_PUBLIC_DEFAULT_MAP_CENTER_LNG=72.877
NEXT_PUBLIC_DEFAULT_MAP_ZOOM=10
"""
            env_local.write_text(env_content)
            print(f"‚úÖ Created {env_local}")
        
        print("‚úÖ Environment setup complete")

    def start_backend(self):
        """Start the AI Trust Engine backend"""
        print("üöÄ Starting AI Trust Engine backend...")
        
        cmd = [
            "python", "-m", "uvicorn",
            "main:app",
            f"--host={self.backend_host}",
            f"--port={self.backend_port}",
            "--reload"
        ]
        
        try:
            self.backend_process = subprocess.Popen(
                cmd,
                cwd=self.ai_engine_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            print(f"‚úÖ Backend started with PID {self.backend_process.pid}")
            return True
        except Exception as e:
            print(f"‚ùå Failed to start backend: {e}")
            return False

    def start_frontend(self):
        """Start the dashboard frontend"""
        print("üöÄ Starting SeaSense dashboard...")
        
        # Check if node_modules exists, if not install dependencies
        node_modules = self.dashboard_dir / "node_modules"
        if not node_modules.exists():
            print("üì¶ Installing dashboard dependencies...")
            try:
                subprocess.run(["npm", "install"], 
                             cwd=self.dashboard_dir, check=True)
            except subprocess.CalledProcessError:
                try:
                    subprocess.run(["yarn", "install"], 
                                 cwd=self.dashboard_dir, check=True)
                except subprocess.CalledProcessError as e:
                    print(f"‚ùå Failed to install dependencies: {e}")
                    return False
        
        cmd = ["npm", "run", "dev"]
        
        try:
            self.frontend_process = subprocess.Popen(
                cmd,
                cwd=self.dashboard_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            print(f"‚úÖ Frontend started with PID {self.frontend_process.pid}")
            return True
        except Exception as e:
            print(f"‚ùå Failed to start frontend: {e}")
            return False

    def wait_for_backend(self, timeout=60):
        """Wait for backend to be ready"""
        print("‚è≥ Waiting for backend to be ready...")
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f"http://{self.backend_host}:{self.backend_port}/health", 
                                      timeout=5)
                if response.status_code == 200:
                    print("‚úÖ Backend is ready!")
                    return True
            except requests.RequestException:
                pass
            
            time.sleep(2)
        
        print("‚ùå Backend failed to start within timeout")
        return False

    def wait_for_frontend(self, timeout=120):
        """Wait for frontend to be ready"""
        print("‚è≥ Waiting for frontend to be ready...")
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f"http://localhost:{self.frontend_port}", 
                                      timeout=5)
                if response.status_code in [200, 404]:  # 404 is ok for Next.js dev server
                    print("‚úÖ Frontend is ready!")
                    return True
            except requests.RequestException:
                pass
            
            time.sleep(3)
        
        print("‚ùå Frontend failed to start within timeout")
        return False

    def monitor_health(self):
        """Monitor the health of both services"""
        while not self.shutdown_event.is_set():
            try:
                # Check backend health
                backend_healthy = False
                try:
                    response = requests.get(f"http://{self.backend_host}:{self.backend_port}/health", 
                                          timeout=5)
                    backend_healthy = response.status_code == 200
                except:
                    pass
                
                # Check frontend health
                frontend_healthy = False
                try:
                    response = requests.get(f"http://localhost:{self.frontend_port}", 
                                          timeout=5)
                    frontend_healthy = response.status_code in [200, 404]
                except:
                    pass
                
                # Check process status
                backend_running = self.backend_process and self.backend_process.poll() is None
                frontend_running = self.frontend_process and self.frontend_process.poll() is None
                
                if not backend_running or not frontend_running:
                    print(f"\n‚ö†Ô∏è  Service status changed:")
                    print(f"   Backend: {'üü¢ Running' if backend_running else 'üî¥ Stopped'}")
                    print(f"   Frontend: {'üü¢ Running' if frontend_running else 'üî¥ Stopped'}")
                    break
                
            except Exception as e:
                print(f"Health monitor error: {e}")
            
            time.sleep(30)  # Check every 30 seconds

    def print_status(self):
        """Print current status and URLs"""
        print("\n" + "="*60)
        print("üåä SeaSense AI Trust Engine - Integration Status")
        print("="*60)
        print(f"üîß Backend API: http://{self.backend_host}:{self.backend_port}")
        print(f"üìö API Docs: http://{self.backend_host}:{self.backend_port}/docs")
        print(f"üìä Dashboard: http://localhost:{self.frontend_port}")
        print(f"üíö Health Check: http://{self.backend_host}:{self.backend_port}/health")
        print("="*60)
        print("üîÑ Integration Features:")
        print("   ‚úÖ Real-time hazard reporting")
        print("   ‚úÖ AI-powered trust scoring")
        print("   ‚úÖ Social media monitoring")
        print("   ‚úÖ Interactive maps & analytics")
        print("   ‚úÖ Graceful fallback to mock data")
        print("="*60)
        print("üí° Usage:")
        print("   ‚Ä¢ Submit reports via dashboard or API")
        print("   ‚Ä¢ Monitor trust scores in real-time")
        print("   ‚Ä¢ View analytics and maps")
        print("   ‚Ä¢ Press Ctrl+C to stop all services")
        print("="*60)

    def start(self):
        """Start the complete SeaSense system"""
        print("üåä Starting SeaSense AI Trust Engine Integration")
        
        if not self.check_dependencies():
            return False
        
        self.setup_environment()
        
        # Start backend
        if not self.start_backend():
            return False
        
        # Wait for backend to be ready
        if not self.wait_for_backend():
            self.shutdown()
            return False
        
        # Start frontend
        if not self.start_frontend():
            self.shutdown()
            return False
        
        # Wait for frontend to be ready
        if not self.wait_for_frontend():
            self.shutdown()
            return False
        
        # Start health monitoring
        self.health_monitor_thread = threading.Thread(target=self.monitor_health)
        self.health_monitor_thread.daemon = True
        self.health_monitor_thread.start()
        
        # Print status
        self.print_status()
        
        return True

    def shutdown(self):
        """Gracefully shutdown all services"""
        print("\nüõë Shutting down SeaSense services...")
        
        self.shutdown_event.set()
        
        if self.frontend_process:
            print("   Stopping frontend...")
            self.frontend_process.terminate()
            try:
                self.frontend_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.frontend_process.kill()
            print("   ‚úÖ Frontend stopped")
        
        if self.backend_process:
            print("   Stopping backend...")
            self.backend_process.terminate()
            try:
                self.backend_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.backend_process.kill()
            print("   ‚úÖ Backend stopped")
        
        print("üåä SeaSense shutdown complete")

    def run(self):
        """Main run method"""
        try:
            if self.start():
                # Keep running until interrupted
                while not self.shutdown_event.is_set():
                    time.sleep(1)
            else:
                print("‚ùå Failed to start SeaSense system")
                return 1
        except KeyboardInterrupt:
            pass
        finally:
            self.shutdown()
        
        return 0


def main():
    """Main entry point"""
    orchestrator = SeaSenseOrchestrator()
    return orchestrator.run()


if __name__ == "__main__":
    sys.exit(main())
